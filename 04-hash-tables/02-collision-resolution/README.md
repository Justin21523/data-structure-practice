# 碰撞處理（Collision Resolution）

## 1. 動機與概述

### 什麼是碰撞？

當兩個不同的鍵（key）經過雜湊函數計算後得到相同的索引值時，稱為**碰撞（collision）**。

```
h("apple")  = 42
h("orange") = 42  ← 碰撞！兩個不同的 key 對應到同一個桶
```

### 為什麼碰撞無法避免？

根據**鴿籠原理（Pigeonhole Principle）**：
- 若有 n 個鍵要放入 m 個桶（n > m）
- 則至少有一個桶會有超過一個鍵

即使 n ≤ m，由於雜湊函數的特性，碰撞仍可能發生。

### 兩大碰撞處理策略

| 策略 | 英文 | 核心概念 |
|------|------|---------|
| 鏈結法 | Chaining | 每個桶維護一個鏈結串列 |
| 開放定址法 | Open Addressing | 碰撞時探測下一個空位 |

## 2. 鏈結法（Chaining）

### 概念

每個桶（bucket）維護一個鏈結串列，所有雜湊到同一位置的元素都存在這個串列中。

```
bucket[0] → null
bucket[1] → (k1,v1) → null
bucket[2] → (k2,v2) → (k5,v5) → (k8,v8) → null
bucket[3] → (k3,v3) → null
bucket[4] → null
```

### 操作

| 操作 | 步驟 | 時間複雜度 |
|------|------|-----------|
| 插入 | 計算 hash → 加入對應桶的串列頭部 | O(1) |
| 搜尋 | 計算 hash → 遍歷對應桶的串列 | O(1 + α) 平均 |
| 刪除 | 計算 hash → 在串列中找到並移除 | O(1 + α) 平均 |

其中 α = n/m 是負載因子。

### 優缺點

| 優點 | 缺點 |
|------|------|
| 實作簡單 | 額外的指標空間 |
| 刪除容易 | Cache 效能較差（非連續記憶體） |
| 負載因子可 > 1 | 串列過長時效能下降 |

### 變體

- **使用動態陣列**：以 ArrayList 取代鏈結串列
- **使用平衡樹**：Java 8+ 的 HashMap 在桶過大時轉為紅黑樹

## 3. 開放定址法（Open Addressing）

### 概念

所有元素都存在雜湊表的桶陣列中。碰撞時，按照特定的**探測序列（probe sequence）**尋找下一個空位。

```
插入 key，h(key) = 3，但 bucket[3] 已滿：

bucket: [  ] [  ] [  ] [X] [X] [  ] [  ] [  ]
              探測 →    ↑   ↑   ↑
                       碰撞 碰撞 插入這裡
```

### 三種探測方法

#### 3.1 線性探測（Linear Probing）

**探測序列**：h(k), h(k)+1, h(k)+2, h(k)+3, ...

```
h(k, i) = (h(k) + i) mod m
```

**優點**：
- 實作最簡單
- Cache 效能最佳（連續存取）

**缺點**：
- **主群聚（Primary Clustering）**：連續佔用的區塊會越來越大

```
群聚現象：
[X][X][X][X][X][  ][  ][X][X][  ]
 ←───群聚────→        ←群聚→

新元素落在群聚區會使群聚更嚴重
```

#### 3.2 二次探測（Quadratic Probing）

**探測序列**：h(k), h(k)+1², h(k)+2², h(k)+3², ...

```
h(k, i) = (h(k) + c₁·i + c₂·i²) mod m

常見設定：c₁ = 0, c₂ = 1
或：c₁ = c₂ = 1/2（需要 m 為質數）
```

**優點**：
- 減少主群聚

**缺點**：
- **次群聚（Secondary Clustering）**：相同 h(k) 的鍵會有相同探測序列
- 可能無法遍歷所有桶（需要特定的 m 值）

#### 3.3 雙重雜湊（Double Hashing）

**探測序列**：使用第二個雜湊函數決定步長

```
h(k, i) = (h₁(k) + i · h₂(k)) mod m

h₂(k) 必須：
- 不為 0
- 與 m 互質（若 m 為質數，h₂(k) < m 即可）
```

**常見設定**：
```
h₁(k) = k mod m
h₂(k) = 1 + (k mod (m-1))
```

**優點**：
- 幾乎沒有群聚問題
- 探測序列分布最均勻

**缺點**：
- 需要計算兩次雜湊
- 實作較複雜

### 開放定址法的刪除問題

直接刪除會破壞探測序列！

```
插入 A (h=3), B (h=3, 探測到 4), C (h=3, 探測到 5)

[  ][  ][  ][A][B][C][  ][  ]

若直接刪除 B：
[  ][  ][  ][A][  ][C][  ][  ]

搜尋 C 時：h(C)=3 → 找到 A → 下一個是空 → 誤判 C 不存在！
```

**解決方案**：使用**墓碑標記（Tombstone）**

```
[  ][  ][  ][A][⚰][C][  ][  ]

⚰ = DELETED 標記
- 搜尋時：跳過墓碑繼續探測
- 插入時：可以覆蓋墓碑
```

### 開放定址法比較

| 特性 | 線性探測 | 二次探測 | 雙重雜湊 |
|------|---------|---------|---------|
| 群聚 | 嚴重 | 中等 | 最少 |
| Cache | 最佳 | 中等 | 較差 |
| 實作 | 最簡單 | 中等 | 較複雜 |
| 雜湊計算 | 1 次 | 1 次 | 2 次 |

## 4. 兩種策略比較

| 特性 | Chaining | Open Addressing |
|------|----------|-----------------|
| 空間 | 額外指標 | 無額外空間 |
| 負載因子 | α 可 > 1 | α 必須 < 1 |
| 刪除 | 簡單 | 需要墓碑 |
| Cache | 較差 | 較佳（線性探測） |
| 適用場景 | 不確定資料量 | 資料量可預估 |

## 5. 時間複雜度分析

假設簡單均勻雜湊（Simple Uniform Hashing）：

### Chaining

| 操作 | 成功搜尋 | 失敗搜尋 |
|------|---------|---------|
| 平均 | O(1 + α/2) | O(1 + α) |

### Open Addressing

| 操作 | 成功搜尋 | 失敗搜尋 |
|------|---------|---------|
| 平均 | O((1/α)·ln(1/(1-α))) | O(1/(1-α)) |

**當 α = 0.5 時**：
- 成功搜尋 ≈ 1.4 次探測
- 失敗搜尋 ≈ 2 次探測

**當 α = 0.9 時**：
- 成功搜尋 ≈ 2.6 次探測
- 失敗搜尋 ≈ 10 次探測

## 6. 程式檔案清單

| 語言 | 檔案 | 說明 |
|-----|------|-----|
| Python | `chaining.py` | 鏈結法實作 |
| Python | `open_addressing.py` | 開放定址法（三種探測） |
| Python | `test_collision.py` | 單元測試 |
| 其他語言 | ... | 相同結構 |

## 7. 考試重點

1. **手動模擬**：給定雜湊函數與插入序列，畫出雜湊表狀態
2. **計算 ASL**：平均成功/失敗搜尋長度
3. **比較分析**：不同碰撞處理方式的優缺點
4. **刪除問題**：為何開放定址法需要墓碑標記

## 8. 延伸閱讀

- 基本雜湊表：見 `../01-basic-hash-table/`
- 雜湊函數設計：見 `../03-hash-functions/`
- CLRS Chapter 11.2-11.4

## 參考資料

- CLRS Chapter 11: Hash Tables
- Knuth, The Art of Computer Programming, Vol. 3
